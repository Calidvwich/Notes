# 1. 变量
Rust中变量的命名规则和其他语言类似，遵循命名规范即可，同时预留的关键字不能作为名字使用
## 1.1 变量的绑定和可变性：
Rust语言下变量和对象是依靠所有关系来存在的。默认情况下，如果对象A与变量a绑定，那么A先前绑定的对象会自动丧失A的所有权。同时，默认情况下变量本身是不可修改的。
比如以下代码：
```
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
注意到此时会报错，原因在于第一次将x和5绑定后，无法再次将x和6绑定。
解决方法是将最开始的赋值语句修改
```
let x=5;变为
let mut x=5;
```
一般而言，Rust会对于没用使用的变量进行报错提示
此时如果不需要报错提示，命名为
```
let _x=5;
```
此时不会报错。

 ## 1.2 变量解构
 考虑以下代码
```
 fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```
这是一个典型的变量结构块。其功能是从一个相对复杂的变量（在这里是（a, mut b）的变量组）中匹配出符合这个变量的部分
Rust 1.59后支持赋值语句左侧使用元组，切片和结构体模式了，这部分会在模式匹配中提到
目前，+=还不支持解构赋值
 ## 1.3 变量和常量
 常量命名：全部字母使用大写，并且使用_分割单词
 常量可以在任意作用域内声明，在声明的作用域以内全部有效。一般而言，程序中用到的硬编码值最好全部声明为常量，以便于后期维护
 常量和变量的区别在于：常量不允许使用mut，自始至终不可修改；常量使用const而非let关键字进行声明，必须标注数值类型。
 1.4 变量遮蔽
 Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的
```
 fn main() {
    let x = 5;
    // 在main函数的作用域内对之前的x进行遮蔽
    let x = x + 1;

    {
        // 在当前的花括号作用域内，对之前的x进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```
注意到变量遮蔽仅仅在其特定的作用域有效，比方说上面程序输出应该是
```
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
   ...
The value of x in the inner scope is: 12
The value of x is: 6
```
这是因为先在外层存在变量x被赋值5，然后新的x覆盖了老的x，此时x被赋值老x+1；第三个let语句功能相似，在内作用域遮蔽了x=6的x，将其赋值为12；
注意，在变量遮蔽的情况下，允许对未声明mut的变量进行遮蔽并且不会因为具体数值类型的不同导致错误；相反，如果使用了mut进行声明，可能会出现错误。
2. 数值基本类型
2.1 类型推导和标注
由于rust本身是静态语言，尽管编译器多数时候能够推导出数值的具体类型，但是在特定情况下仍然需要进行数值类型的标注
2.2 字符类型（char）
Rust中的字符支持所有符合UNICODE编码的数值，因此中文汉字，字母，emoji等都可。和其他语言相同的是，字符内容要用' '来框起来。同时，基于UNICODE编码格式，我们可以得到一个Char是4字节的
2.3 布尔类型（bool）
占用1个字节，仅包括两个数值：true, false；
2.4 单元类型 
仅包括(), 数值也是(), main函数就返回这个单元类型 ()，你不能说main函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：发散函数( diverge function )，顾名思义，无法收敛的函数。例如常见的 println!()的返回值也是单元类型 ()。再比如，你可以用 () 作为 map的值，表示我们不关注具体的值，只关注 key。
